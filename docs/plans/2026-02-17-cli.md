# Buddha.js CLI Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a `buddha` CLI with 8 commands exposing the full library interactively from the terminal.

**Architecture:** Commander.js routes subcommands to handler modules in `src/cli/commands/`. Each handler is a thin wrapper around library classes. Inquirer.js handles interactive prompts, Chalk styles output. A shared `format.ts` provides consistent terminal formatting. The CLI entry point is `src/cli/index.ts`, compiled to `dist/cli.js` with a shebang.

**Tech Stack:** TypeScript, Commander.js, Inquirer.js, Chalk, tsup, Vitest

---

### Task 1: Install dependencies, scaffold CLI entry point and format utilities

**Files:**
- Modify: `package.json`
- Create: `src/cli/index.ts`
- Create: `src/cli/utils/format.ts`

**Step 1: Install dependencies**

```bash
npm install commander @inquirer/prompts chalk
```

Note: Use `@inquirer/prompts` (the modern ESM-friendly Inquirer). It exports `input`, `select`, `checkbox`, `confirm` as standalone functions.

**Step 2: Add bin field and build:cli script to package.json**

Add to package.json:
```json
{
  "bin": {
    "buddha": "./dist/cli.js"
  },
  "scripts": {
    "build:cli": "tsup src/cli/index.ts --format esm --outDir dist --out-extension .js --banner.js '#!/usr/bin/env node'"
  }
}
```

Keep the existing `build` script as-is for the library. Add `build:cli` as a separate script.

**Step 3: Create `src/cli/utils/format.ts`**

```ts
import chalk from 'chalk';

export function header(text: string): string {
  return chalk.bold.cyan(`\n‚ïê‚ïê‚ïê ${text} ‚ïê‚ïê‚ïê\n`);
}

export function label(text: string): string {
  return chalk.bold(text);
}

export function insight(text: string): string {
  return chalk.italic.yellow(text);
}

export function success(text: string): string {
  return chalk.green(text);
}

export function subtle(text: string): string {
  return chalk.dim(text);
}

export function stage(name: string, description: string): string {
  return `${chalk.bold.magenta(name)} ${chalk.dim('‚Äî')} ${description}`;
}

export function divider(): string {
  return chalk.dim('‚îÄ'.repeat(50));
}
```

**Step 4: Create `src/cli/index.ts`**

```ts
#!/usr/bin/env node
import { Command } from 'commander';

const program = new Command();

program
  .name('buddha')
  .description('Buddha.js ‚Äî Buddhist concepts from the terminal')
  .version('0.1.0');

// Commands will be registered here in subsequent tasks

program.parse();
```

**Step 5: Verify it builds**

```bash
npm run build:cli
```

Check that `dist/cli.js` exists and has the shebang.

**Step 6: Verify it runs**

```bash
node dist/cli.js --help
```

Expected: Shows help with "buddha" name and description.

**Step 7: Commit**

```bash
git add package.json package-lock.json src/cli/index.ts src/cli/utils/format.ts
git commit -m "feat: scaffold CLI entry point with Commander, format utilities"
```

---

### Task 2: One-shot commands (inquiry, chain, status)

These are the simplest commands ‚Äî no interactive prompts, just create objects and print results.

**Files:**
- Create: `src/cli/commands/inquiry.ts`
- Create: `src/cli/commands/chain.ts`
- Create: `src/cli/commands/status.ts`
- Modify: `src/cli/index.ts`

**Step 1: Create `src/cli/commands/inquiry.ts`**

```ts
import { Being } from '../../simulation/Being';
import { header, label, insight, divider } from '../utils/format';

export function inquiry(): void {
  const being = new Being();
  const result = being.investigateSelf();

  console.log(header('Self Investigation'));

  console.log(label('Aggregate Search:'));
  console.log(`  Self found: ${result.aggregateSearch.selfFound}`);
  console.log(`  Searched in: ${result.aggregateSearch.searchedIn.join(', ')}`);
  console.log(`  ${result.aggregateSearch.conclusion}`);

  console.log();
  console.log(label('Dependent Origination:'));
  console.log(`  ${result.dependentOriginationInsight}`);

  if (result.emptinessInsight) {
    console.log();
    console.log(label('Emptiness Analysis:'));
    console.log(`  Phenomenon: ${result.emptinessInsight.phenomenon}`);
    console.log(`  Inherent nature: ${result.emptinessInsight.inherentNature}`);
    console.log(`  Depends on: ${result.emptinessInsight.dependsOn.join(', ')}`);
  }

  console.log();
  console.log(divider());
  console.log(insight(result.conclusion));
}
```

**Step 2: Create `src/cli/commands/chain.ts`**

```ts
import { DependentOrigination } from '../../dependent-origination/DependentOrigination';
import { header, label, insight, subtle, divider } from '../utils/format';

export function chain(): void {
  const do_ = new DependentOrigination();

  console.log(header('Dependent Origination ‚Äî The 12 Links'));

  const chainState = do_.getChainState();
  for (const link of chainState) {
    const arrow = link.position < 12 ? ' ‚Üí' : '';
    console.log(`  ${subtle(`${link.position}.`)} ${label(link.name)} ${subtle(`(${link.sanskritName})`)}${arrow}`);
  }

  console.log();
  console.log(divider());
  console.log(label('Liberation Point:'));
  console.log(insight(do_.practiceAtLiberationPoint()));
}
```

**Step 3: Create `src/cli/commands/status.ts`**

```ts
import { Being } from '../../simulation/Being';
import { header } from '../utils/format';

export function status(): void {
  const being = new Being();

  console.log(header('Being Status'));
  console.log(being.getSummary());
}
```

**Step 4: Register commands in `src/cli/index.ts`**

Update `src/cli/index.ts` to import and register all three commands:

```ts
#!/usr/bin/env node
import { Command } from 'commander';
import { inquiry } from './commands/inquiry';
import { chain } from './commands/chain';
import { status } from './commands/status';

const program = new Command();

program
  .name('buddha')
  .description('Buddha.js ‚Äî Buddhist concepts from the terminal')
  .version('0.1.0');

program
  .command('inquiry')
  .description('Investigate the nature of self')
  .action(inquiry);

program
  .command('chain')
  .description('Display the 12 links of dependent origination')
  .action(chain);

program
  .command('status')
  .description('Show the current state of a being')
  .action(status);

program.parse();
```

**Step 5: Build and test manually**

```bash
npm run build:cli
node dist/cli.js inquiry
node dist/cli.js chain
node dist/cli.js status
```

Verify each produces formatted output.

**Step 6: Commit**

```bash
git add src/cli/commands/inquiry.ts src/cli/commands/chain.ts src/cli/commands/status.ts src/cli/index.ts
git commit -m "feat: add inquiry, chain, and status CLI commands"
```

---

### Task 3: Simple interactive commands (sit, koan)

These commands use Inquirer prompts for input.

**Files:**
- Create: `src/cli/commands/sit.ts`
- Create: `src/cli/commands/koan.ts`
- Modify: `src/cli/index.ts`

**Step 1: Create `src/cli/commands/sit.ts`**

```ts
import { input, confirm } from '@inquirer/prompts';
import { PoisonArrow } from '../../simulation/PoisonArrow';
import { header, stage, insight, divider, success } from '../utils/format';

export async function sit(): Promise<void> {
  console.log(header('Poison Arrow ‚Äî Quick Cessation'));
  console.log('Based on the Cula-Malunkyovada Sutta: remove the arrow first.\n');

  const suffering = await input({
    message: 'What suffering are you sitting with?',
  });

  const sim = new PoisonArrow(suffering);

  while (!sim.isComplete()) {
    const step = sim.step();
    console.log();
    console.log(stage(step.stage.toUpperCase(), `Truth of ${step.truth}`));
    console.log(insight(step.insight));
    console.log(`  ${step.guidance}`);

    if (!sim.isComplete()) {
      await input({ message: 'Press Enter to continue...' });
    }
  }

  console.log();
  console.log(divider());
  console.log(success('The arrow has been removed.'));
  console.log();
  console.log(sim.getSummary());
}
```

**Step 2: Create `src/cli/commands/koan.ts`**

```ts
import { input, confirm } from '@inquirer/prompts';
import { KoanGenerator } from '../../koan/KoanGenerator';
import { header, label, insight, subtle, divider, success } from '../utils/format';
import chalk from 'chalk';

export async function koan(options: { id?: string }): Promise<void> {
  const generator = new KoanGenerator();

  let continueLoop = true;
  while (continueLoop) {
    const k = options.id ? generator.present(options.id) : generator.present();

    console.log(header(k.title));
    console.log(k.case);
    console.log(subtle(`‚Äî ${k.source}`));

    if (k.hint) {
      console.log(subtle(`\nHint: ${k.hint}`));
    }

    console.log();
    const response = await input({
      message: 'Contemplate and respond:',
    });

    const result = generator.contemplate(k.id, response);

    console.log();
    if (result.isNonDual) {
      console.log(success('No dualistic traps detected.'));
    } else {
      console.log(label('Traps detected:'));
      for (const trap of result.trapsDetected) {
        console.log(`  ${chalk.red('‚Ä¢')} ${trap}`);
      }
    }

    console.log();
    console.log(insight(result.reflection));
    console.log(divider());

    continueLoop = await confirm({
      message: 'Try another koan?',
      default: false,
    });

    // Clear specific ID after first round so subsequent koans are random
    options = {};
  }
}
```

**Step 3: Register commands in `src/cli/index.ts`**

Add imports and registrations:

```ts
import { sit } from './commands/sit';
import { koan } from './commands/koan';
```

```ts
program
  .command('sit')
  .description('Guided cessation through the Poison Arrow method')
  .action(sit);

program
  .command('koan')
  .description('Contemplate a Zen koan')
  .option('--id <id>', 'Present a specific koan by ID')
  .action(koan);
```

**Step 4: Build and test manually**

```bash
npm run build:cli
node dist/cli.js sit
node dist/cli.js koan
node dist/cli.js koan --id mu
```

**Step 5: Commit**

```bash
git add src/cli/commands/sit.ts src/cli/commands/koan.ts src/cli/index.ts
git commit -m "feat: add sit and koan interactive CLI commands"
```

---

### Task 4: Multi-step interactive commands (diagnose, karma)

**Files:**
- Create: `src/cli/commands/diagnose.ts`
- Create: `src/cli/commands/karma.ts`
- Modify: `src/cli/index.ts`

**Step 1: Create `src/cli/commands/diagnose.ts`**

```ts
import { checkbox } from '@inquirer/prompts';
import { EightfoldPath } from '../../eightfold-path/EightfoldPath';
import { FourNobleTruths } from '../../four-noble-truths/FourNobleTruths';
import { header, label, insight, divider } from '../utils/format';

const SUFFERING_CHOICES = [
  { name: 'Physical pain', value: 'physical' },
  { name: 'Mental anguish', value: 'mental' },
  { name: 'Existential unease', value: 'existential' },
  { name: 'Pain of change', value: 'change' },
  { name: 'Conditioned existence', value: 'conditioned' },
];

const CRAVING_CHOICES = [
  { name: 'Craving for sensual pleasures', value: 'craving-for-sensual-pleasures' },
  { name: 'Craving for existence', value: 'craving-for-existence' },
  { name: 'Craving for non-existence', value: 'craving-for-non-existence' },
];

export async function diagnose(): Promise<void> {
  console.log(header('Four Noble Truths ‚Äî Diagnosis'));

  const suffering = await checkbox({
    message: 'What types of suffering are present?',
    choices: SUFFERING_CHOICES,
    required: true,
  });

  const cravings = await checkbox({
    message: 'What cravings are active?',
    choices: CRAVING_CHOICES,
    required: true,
  });

  const path = new EightfoldPath();
  const truths = new FourNobleTruths(path);

  const diagnosis = truths.diagnose({
    suffering: suffering as any[],
    cravings: cravings as any[],
  });

  console.log();
  console.log(label('Suffering:'));
  console.log(`  Types: ${diagnosis.suffering.types.join(', ')}`);
  console.log(`  Intensity: ${diagnosis.suffering.intensity}`);
  console.log(`  Deepest: ${diagnosis.suffering.deepestType}`);

  console.log();
  console.log(label('Cause:'));
  console.log(`  Cravings: ${diagnosis.cause.cravingTypes.join(', ')}`);
  console.log(`  Root poisons: ${diagnosis.cause.rootPoisons.join(', ')}`);

  console.log();
  console.log(label('Cessation:'));
  console.log(`  Possible: ${diagnosis.cessationPossible.isPossible}`);
  console.log(`  Difficulty: ${diagnosis.cessationPossible.difficulty}`);
  console.log(`  Timeframe: ${diagnosis.cessationPossible.timeframe}`);

  console.log();
  console.log(label('Path Forward:'));
  console.log(`  Focus area: ${diagnosis.path.focusArea}`);
  console.log(`  Practices: ${diagnosis.path.practices.join(', ')}`);

  console.log(divider());
  console.log(insight('The diagnosis is complete. The path is clear.'));
}
```

**Step 2: Create `src/cli/commands/karma.ts`**

```ts
import { input, select } from '@inquirer/prompts';
import { Being } from '../../simulation/Being';
import { header, label, insight, subtle, divider, success } from '../utils/format';
import chalk from 'chalk';

export async function karma(): Promise<void> {
  const being = new Being();

  console.log(header('Karma ‚Äî Intentional Action'));
  console.log('Every action plants a seed. What will you cultivate?\n');

  let running = true;
  while (running) {
    const action = await select({
      message: 'What would you like to do?',
      choices: [
        { name: 'Perform an action', value: 'act' },
        { name: 'Receive karmic results', value: 'receive' },
        { name: 'View karmic stream', value: 'view' },
        { name: 'Quit', value: 'quit' },
      ],
    });

    switch (action) {
      case 'act': {
        const description = await input({ message: 'Describe the action:' });
        const quality = await select({
          message: 'Quality:',
          choices: [
            { name: 'Wholesome', value: 'wholesome' },
            { name: 'Unwholesome', value: 'unwholesome' },
          ],
        });
        const intensity = await select({
          message: 'Intensity (1-10):',
          choices: [3, 5, 7, 9].map(n => ({ name: `${n}`, value: n })),
        });
        const root = await select({
          message: 'Root:',
          choices: quality === 'wholesome'
            ? [
                { name: 'Non-greed (generosity)', value: 'non-greed' },
                { name: 'Non-hatred (loving-kindness)', value: 'non-hatred' },
                { name: 'Non-delusion (wisdom)', value: 'non-delusion' },
              ]
            : [
                { name: 'Greed', value: 'greed' },
                { name: 'Hatred', value: 'hatred' },
                { name: 'Delusion', value: 'delusion' },
              ],
        });

        const k = being.act(description, quality as any, intensity as any, root as any);
        console.log(success(`\n  Karma created: ${k.quality} (intensity ${k.intensity})\n`));
        break;
      }

      case 'receive': {
        const results = being.receiveKarmicResults();
        if (results.length === 0) {
          console.log(subtle('\n  No karma has ripened yet.\n'));
        } else {
          console.log(label('\n  Karmic Results:'));
          for (const r of results) {
            const color = r.feeling === 'pleasant' ? chalk.green : r.feeling === 'unpleasant' ? chalk.red : chalk.gray;
            console.log(`    ${color('‚Ä¢')} ${r.description} (${r.feeling})`);
          }
          console.log();
        }
        break;
      }

      case 'view': {
        const stream = being.getKarmicStream();
        if (stream.length === 0) {
          console.log(subtle('\n  No actions taken yet.\n'));
        } else {
          console.log(label('\n  Karmic Stream:'));
          for (const k of stream) {
            const symbol = k.quality === 'wholesome' ? chalk.green('‚óè') : chalk.red('‚óè');
            console.log(`    ${symbol} ${k.intention.description} (${k.quality}, intensity ${k.intensity})`);
          }
          console.log();
        }
        break;
      }

      case 'quit':
        running = false;
        break;
    }
  }

  console.log(divider());
  const state = being.getState();
  console.log(insight(`Session complete. ${state.pendingKarma} karmic seeds planted.`));
}
```

**Step 3: Register commands in `src/cli/index.ts`**

Add imports and registrations:

```ts
import { diagnose } from './commands/diagnose';
import { karma } from './commands/karma';
```

```ts
program
  .command('diagnose')
  .description('Diagnose suffering using the Four Noble Truths')
  .action(diagnose);

program
  .command('karma')
  .description('Explore intentional action and karmic results')
  .action(karma);
```

**Step 4: Build and test manually**

```bash
npm run build:cli
node dist/cli.js diagnose
node dist/cli.js karma
```

**Step 5: Commit**

```bash
git add src/cli/commands/diagnose.ts src/cli/commands/karma.ts src/cli/index.ts
git commit -m "feat: add diagnose and karma interactive CLI commands"
```

---

### Task 5: Meditate command (real-time timer)

The most complex command ‚Äî uses MeditationTimer with real-time readline for check-ins.

**Files:**
- Create: `src/cli/commands/meditate.ts`
- Modify: `src/cli/index.ts`

**Step 1: Create `src/cli/commands/meditate.ts`**

This command uses Node's `readline` for raw keypress handling during the meditation session (not Inquirer, since we need non-blocking input during a timer).

```ts
import * as readline from 'readline';
import { MeditationTimer } from '../../meditation/MeditationTimer';
import { header, label, insight, success, subtle, divider } from '../utils/format';
import chalk from 'chalk';

export async function meditate(options: { interval?: string }): Promise<void> {
  const duration = 5;
  const intervalBell = options.interval ? parseInt(options.interval, 10) : 60;

  console.log(header('Meditation Timer'));
  console.log(`Duration: ${duration} minutes`);
  console.log(`Interval bell: every ${intervalBell}s`);
  console.log(subtle('\nPress Enter to check in (record a mindful moment).'));
  console.log(subtle('Press q + Enter to stop early.\n'));

  const timer = new MeditationTimer({
    duration: duration * 60,
    intervalBell,
    onBell: () => {
      process.stdout.write(chalk.yellow('  üîî Bell\n'));
    },
  });

  timer.start();

  return new Promise<void>((resolve) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    const updateInterval = setInterval(() => {
      const remaining = timer.getRemainingSeconds();
      if (remaining <= 0) {
        clearInterval(updateInterval);
        rl.close();
        finishSession(timer);
        resolve();
      }
    }, 1000);

    rl.on('line', (line) => {
      if (line.trim().toLowerCase() === 'q') {
        clearInterval(updateInterval);
        rl.close();
        finishSession(timer);
        resolve();
        return;
      }

      if (timer.isRunning()) {
        timer.checkIn();
        const elapsed = timer.getElapsedSeconds();
        const remaining = timer.getRemainingSeconds();
        console.log(success(`  ‚úì Check-in at ${elapsed}s (${remaining}s remaining)`));
      }
    });
  });
}

function finishSession(timer: MeditationTimer): void {
  if (!timer.isRunning()) return;

  const session = timer.stop();

  console.log();
  console.log(divider());
  console.log(header('Session Complete'));

  console.log(label('Duration:') + ` ${session.duration}s`);
  console.log(label('Mindful moments:') + ` ${session.mindfulMoments}`);
  console.log(label('Mindfulness ratio:') + ` ${(session.mindfulnessRatio * 100).toFixed(0)}%`);
  console.log(label('Longest distraction:') + ` ${session.longestDistraction}s`);

  const qualityColors: Record<string, typeof chalk.green> = {
    absorbed: chalk.green,
    sustained: chalk.cyan,
    intermittent: chalk.yellow,
    scattered: chalk.red,
  };
  const colorFn = qualityColors[session.quality] || chalk.white;
  console.log(label('Quality:') + ` ${colorFn(session.quality)}`);

  if (session.distractionPeriods.length > 0) {
    console.log();
    console.log(label('Distraction periods:'));
    for (const dp of session.distractionPeriods) {
      console.log(subtle(`  ${dp.start}s ‚Üí ${dp.end}s (${dp.duration}s)`));
    }
  }

  console.log();
  console.log(insight(getQualityMessage(session.quality)));
}

function getQualityMessage(quality: string): string {
  switch (quality) {
    case 'absorbed': return 'Deep presence. The mind rests in stillness.';
    case 'sustained': return 'Good continuity. Awareness returns quickly after wandering.';
    case 'intermittent': return 'Some presence, some distraction. This is normal practice.';
    case 'scattered': return 'The mind was restless. Every sitting counts ‚Äî just showing up matters.';
    default: return 'Session complete.';
  }
}
```

**Step 2: Register the meditate command in `src/cli/index.ts`**

Add import and registration:

```ts
import { meditate } from './commands/meditate';
```

```ts
program
  .command('meditate')
  .description('Start a meditation session with mindful check-ins')
  .option('--interval <seconds>', 'Seconds between interval bells', '60')
  .action(meditate);
```

**Step 3: Build and test manually**

```bash
npm run build:cli
node dist/cli.js meditate --interval 10
```

Test by pressing Enter a few times, then press q + Enter to stop.

**Step 4: Commit**

```bash
git add src/cli/commands/meditate.ts src/cli/index.ts
git commit -m "feat: add meditate interactive CLI command with real-time timer"
```

---

### Task 6: README, CLAUDE.md, TODO updates

**Files:**
- Modify: `README.md`
- Modify: `CLAUDE.md`
- Modify: `TODO.md`

**Step 1: Add CLI section to README.md**

Add a `## CLI` section after the Quick Start section. Include:
- Installation: `npm install -g buddha-js` or `npx buddha`
- All 8 commands with brief descriptions
- Example usage for 2-3 key commands (meditate, koan, sit)

**Step 2: Update CLAUDE.md**

Add CLI to the module table:
```
| `cli/` | `buddha` CLI | Terminal interface for all library features |
```

Add CLI commands to the Commands section at the top:
```
npm run build:cli    # Build CLI
node dist/cli.js     # Run CLI
```

**Step 3: Mark TODO complete**

Change:
```
- [ ] **CLI**: Develop a command-line interface for interacting with Buddha.js concepts from the terminal.
```
To:
```
- [x] **CLI**: Develop a command-line interface for interacting with Buddha.js concepts from the terminal.
```

**Step 4: Run existing tests (ensure no regressions)**

```bash
npx vitest run
```
Expected: ALL 196 tests pass (CLI has no unit tests ‚Äî it's a thin presentation layer over tested library classes).

**Step 5: Commit**

```bash
git add README.md CLAUDE.md TODO.md
git commit -m "docs: add CLI documentation and mark TODO complete"
```
